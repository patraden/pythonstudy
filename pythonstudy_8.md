# pythonstudy :memo:
## Lecture #8 [Link](https://www.youtube.com/watch?v=2XFaK3bgT7w)
### продолжение рекурсии
#### генерация перестановок
всего перестановок n!
упрощаем, все числа он 0000..00 до n-1...n-1 (всевозможные числа в n ричной системе счисления)
```python
def gen_bin(m:int,prefix=""):
    if m==0:
        print(prefix)
        return
    gen_bin(m-1, prefix+"0")
    gen_bin(m-1, prefix+"1")

def generate_numbers(n:int,m:int,prefix=None):
    """ Генерирует все числа (с лидирующими незначащими нулями)
    в n-ричной системе счисления (n<=10)
    длины m """
    if m==0:
        print(*prefix,sep="")
        return
    prefix=prefix or []
    for digit in range(n): # рекурентный вызов в цикле
        prefix.append(digit)
        generate_numbers(n,m-1,prefix)
        prefix.pop()

def find(number,A):
    """ Ищет number в A и возвращает True, если такой есть
    False, если такого нет """
    for x in A:
        if number == x:
            return True
    return False

def generate_permutations(n:int, m:int=-1, prefix=None):
    """ Генерация перестановок n чисел в m позициях,
    с префиксом prefix """
    m=n if m==-1 else m # по умолчанию n чисел в n позициях
    prefix=prefix or []
    if m == 0:
        print(*prefix,sep="")
        return
    for number in range(1,n+1):
        if find(number, prefix):
            continue # пропустит шаг цикла
        prefix.append(number)
        generate_permutations(n,m-1,prefix)
        prefix.pop()

if __name__ == "__main__":
    generate_permutations(5,5)
#    generate_numbers(3,3)
#    gen_bin(3)
```

[книга Александра Шень, где можно найти алгоритм генерации перестановок без рекурсии](https://www.mccme.ru/free-books/shen/shen-progbook.pdf)

#### рекурентные сортировки
##### бысрая сортировка Тони Хоара
* W(nlog(n)) #не всегда работает хорошо, существуют такие массивы, на которых она работает плохо как O(n*n)
* сортирующее действие выполняется на прямом ходу рекурсии
* не требует дополнительной памяти
* "разделяй и властвуй"

логически сортировка разбивает все на 3 группы:
* группа "содатов" меньше по росту произвольного "барьерного" элемента
* группа равных по росту (этих дальше сортировать не надо)
* граппу тех, кто "выше"

##### сортировка слиянием
* O(nlog(n))
* сортирующее действие выполняется на обратном ходу рекурсии
* нужно O(n) дополнительной памяти

разделяем на два списка:
* часть списка от 0 до n//2 не включительно
* от n//2 включительно до n невлючительно
далее каждый список сортируется (как-то)
потом сравниваем поэлементно и формируем конечный список (двигаемя по двум индексам).При равенстве элементов уславляваемя из какого списка взять первым и вторым
в конце оин список будет пустым, а во втором последовательно отсортированно будут находится "большие" элементы, которые достаточно "слиять" с результирующим списком
