# pythonstudy :memo:
## Lecture #10 [Link](https://www.youtube.com/watch?v=EdhN_gEDfUM)
### бинарный поиск.реализация

**Важно!** массив должен быть отсортирован
скорость поиска O(log2(n))

```python
def left_bound(A,key):
 left=-1
 right=len(A)
 while right-left > 1:
  middle = (left+right)//2
  if A[middle] < key:
   left=middle
  else:
   right=middle
 return left

def right_bound(A,key):
 left=-1
 right=len(A)
 while right-left > 1:
  middle = (left+right)//2
  if A[middle] <= key:
   left=middle
  else:
   right=middle
 return right
```
### динамическое программирование
поговорим о числах фибоначи

```python
def fib(n):
 if n<=1:
  return n
 return fib(n-1)+fib(n-2)
# дерево вычисления становится большим и во втором слагаемом fib(n-2)не используются результаты первого fib(n-1)
# в результате ассимптотика становится O(fib(n)), что есь экспоненциальный рост. Алгоритм крайне медленный. На бумаге будет гораздо быстрее
```
**как же это сделать?**

```python
# пример динамического программирования, где рекурсия вывернута наоборот
# создадим массив чисел фибоначи fib = [0,1]+[0]*(n-1)
def fibb(n):
 fib = [0,1]+[0]*(n-1)
 for i in range (2, n+1):
   fib[i]=fib[i-1]+fib[i-2]
 return fib[n]
```

#### примеры простейших алгоритмов динамическое программирование
задача:
кузнечик прыгает по числовой прямой от 1 до N совершаю прыжки либо на 1, либо на 2 клетки (други вариантов нет).
Вопрос: сколько различных траекторий может выбрать кузнечик, чтобы добраться до N
Размышлять удобно рекуретно. на последнем прыжке до N клетки можно допрагть только 2 способами:
* с клетки N-2 за 1 прыжок на 2 клетки
* с клетки N-1 за 1 прыжок на 1 клетку
K(n)=K(n-2) # количество способов попасть в n-2 + K(n-1) # количество способов попасть в точку K(n-1)
однако если реализовывать таким образом то нарвемся на ассимптотику чисел фибоначи, поэтому рассуждаем от начала:
в точку "2" можно попасть 2 способами:
* из точки "0" 0 способов
* из точки "1" 1 способом

```python
def traj_num(n):
 k=[0,1]+[0]*n
 for i in range(2,n):
  k[i]=k[i-2]+k[i-1]
 return k[n]
# число траекторий равно числу фибоначи
```
усложним задачу через запрет на клетки, например нельзя прыгать на "4", на "7" и т.д.
либо же можно еще прыгать на 3 клетки

```python
# условие: запретим некоторые клетки
# будет 3 вида шага +1,+2,+3
def count_trajectories(n, allowed:list):
 k=[0,1,int(allowed[2])]+[0]*(n-3) # нулевая точно запрещена, вторая тоно разрешена, мы на ней стоим
 for i in range (3,n+1):
  if allowed[i]:
 return k[n]
```

усложним задачу еще раз введя стоимость достижения клетки n
price[i] - стоимость посещения клетки
cost[i] - минимальная стоимость достижения клетки i

алгоритм:
выбираем предыдущую траекторию по меньшей цене (выбираем тот пункт, куда до последнего шага было дешевле добраться)
cost[i]=price[i]+min(cost[i-2],cost[i-1])
"0" - вая клекта недостижима! пожтому начнем расчет "1" и "2" клетки
cost[1]=price[1]
cost[2]=price[1]+price[2]

```python
def count_min_cost(n, price:list):
 cost=[float("-inf"), price[1], price[1]+price[2]]+[0]*(n-2)
 for i in range(3, n+1):
  cost[i]=price[i]+min(price[i-2], price[i-1])
 return cost[n]
```

#### двумерное динамическое программирование
##### двумерные массивы
по факту их не существуют
существует два пути создания:
1. A=(n*m). линеаризация A[i,j]=A[i*m+j] # ширина массива должна быть фиксирована
1. создания "списка списков" nested array. 
 * A=[[0]*m for i in range(n)] **правильно!**, поскольку каждая новая строка генерируется как новый массив
 * A=[[0]*m]*n - так создавать **нельзя**, поскольку все строки кроме первой будут ссылаться на первую (A[0] is A[1])=False (так можно проверять ссылки в Питоне на один и тот же объект)
