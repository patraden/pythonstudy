# pythonstudy :memo:
## Lecture #16 [Link](https://www.youtube.com/watch?v=4tBrZoi37VI&list=PLRDzFCPr95fK7tr47883DFUbm4GeOjjc0&index=15)
### Индуктивные функции. Однопроходные алгоритмы.

все алгоритмы можно классифицировать на 4 типа:

число => число
число => последовательность (генерирующие алгоритмы, например, арифметические и прочие прогрессии )
последовательность =>  число (однопроходные, т.е независимые от количества памяти и неоднопроходные)
последовательность => последовательность

```python
A=[x1,x2,...,xn]
[f(x) for x in A]
```
в питоне есть специальная функция map

f([x1,x2,...,xn])=fn
f([x1,x2,...,xn,xn+1])=fn+1
fn+1=F(fn,xn+1) - индуктивная функция, которая может или не может существовать в алгоритме
среднее арифметическое не является индуктивной функцией, но по вектор функции (сумма, кол-во) это можно свести к индуктивной функции


функции | имя | [] | [x1] | F(fn,x)
-- | -- | -- | -- | --
количество (len) | n | 0 | 1 | n=n+1
сумма (sum) | s | 0 | x1 | s=s+x
произведение | p | 1 | x1 | p=p*x
хотя бы один (any) | bs | False | c(x1) | bs=bs or c(x)
все (all) | bp | True | c(x1) | bs=bs and c(x)
максимум (max) | m | n/a | x1 | m=max(m,x)
частотный анализ | f | | | f[x]+=1

O(1) по памяти!

### Асимптотика алгоритмов

первый критичный ресурс, потребляемый алгоритмом - память
N operations ~ Time work зависит от реальных входных данных
N operations - могут вести себя по разному на разных выборках [x1,x2,...,xn] (пример пузырьковая сортировка, может быть O(n) но в худщем O(n*n)
так же важна среднестатистическое значение вмете с наихудшим случаем
N - масштаб задачи, иногда он не совсем очевиден. Пример - разложение на множители
мы говорим что количество операций = O(f(N)) значит что существует такое N0 и такая констанца что для любого N>N0 количество операций будет меньше
алгоритмы полного перебора крайне нехороши!
* O(1)  алгоритмы с фиксированных кол-вом операций
* O(log N)  например метод деления пополам
* O(N) однопроходные алгоритмы (частотный анализ, например)
* O(N+M) однопроходные алгоритмы с где M уже количество памяти
* O(N*M)
* O(N*logN) сортировка слиянием
* O(N*N)
* O(N*N*N) сортировка "дурака", но такие алгоритмы бывают (алгоритмы на графах)
* O(N!)
* O(2^N) комбинаторные алгоритмы и полные переборы (NP полные задачи)

### Разложение числа на множители
#### Тест простоты Ферма

для любого p: для любого а (a не делится на p: a^(p-1)=1modp
p=3 a=5
a^2=25 mod 3 = 1
в итоге мы можем находить вероятно простое число с высокой вероятностью




