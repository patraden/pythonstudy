# pythonstudy :memo:
## Lecture #11 [Link](https://www.youtube.com/watch?v=m4HOkVeN4Mo)
### двумерное динамическое программирование

#### задача про шахматного короля
шахматный король живет на поле M*N
требуется узнать, сколькими способами король может добрать из клетки (1,1) до (M,N), если король может ходить только "вправо" и "вниз"
Knm - количество способов достич точку (N,M)
в (i,j) можно попасть только 2 способами:
* из клетки (i-1,j)
* из клетки (i, j-1)
таким образом, Kij=K(i-1)j+Ki(j-1)
крайний случай
в клетку 1,1 и более того клетки 1,j и i,1 для любых N,M можно попасть только 1 способом
дополняем массив абстрактными "барьерными" 0-выми элементами.

0 |0 | 0| 0| 0| 0| 0
--|--|--|--|--|--|--
0 |1 |1 |1 |1 |1 |1
0 |1 |2 |3 |4 |5 |6
0 |1 |3 |6 |10|15|21
0 |1 |4 |10|20|35|56
0 |1 |5 |15|35|70|126
0 |1 |6 |21|56|126|252

по факту мы получили "треугольник паскаля"
в итоге обход по доске и вычисление можно организовать 3 способами:
* слева-направо с сверху-вниз
* сверху-вниз и слева-направо
* паралелльно запускать несколько процессов обхода (параллельное программирование - **Важный и интересный вопрос**)

#### наибольшая общая подпоследовательность
A,B -одномерные  массивы чисел len(A)=n, len(B)=m
нас интересует, какая максимальная возможная общая подпоследовательность существует между ними. подпоследовательность - некоторые список С, содержащий элементы А в исходном порядке, но возможно не все.
[] - подпоследоватлеьно для любого массива
Fij-это длина наибольшей возможной подпоследовательности частей А и B:
часть А длины i A[0:i] - часть А, сожержащая первые i элементов
B[0:j] - часть B первых j элементов
Fij=[  F(i-1)(j-1)+1  if A[i]=B[j]  ] or [  max(Fi(j-1)F(i-1)j)  if A[i]!=B[j]  ]
F0j=0
Fi0=0

```python
def lcs(a,b): # largest common subsequence
 F=[[0]*(len(b)+1) for i in range(len(a)+1)]
 for i in range(1,len(a)+1):
  for j in range(1,len(b)+1):
   if a[i-1]==b[j-1]:
    F[i][j]=1+F[i-1][j-1]]
   else:
    F[i][j]=max(F[i-1][j],F[i][j-1])
 return F[-1][-1]
```
**дополнительно написать алгоритм для вывода подпоследовательности**

#### наибольшая возрастающая подпоследовательность (упорядочена)
Fi-НВП для части A[0:i], которая зананчивается и содердит элемент ai=A[i-1]
Fi=max(Fj)+1,для всех j<i и a[i]>a[j] #рекурентная формула
F0=0
поиск очередного максимума будем начинать с 0

```python
def gis(A): # greatest increasing subsequence
 F=[0]*(len(A)+1)
 for i in range(1,len(A)+1):
  m=0 #max
  for j in range(i):
   if A[i]>A[j] and F[j]>m:
    m=F[j]
  F[i]=m+1
 return F[len(A)]
```

#### алгоритм укладки рюкзака
есть мешок и набор предметов разных размеров и массы
M - максимальный вес вещей, которые можно уложить в мешок
у каждого предмета кроме массы есть стоимость, т.е. пара хракетистик (mi,si)
вопрос - какую максимальную стоимость предметов можно унести
(данная задача не решается лучше, чем методом полного перебора)
однако, если массы дискретны, то эту задачу можно решить методом динамического программирования

#### алгоритм левенштейна
