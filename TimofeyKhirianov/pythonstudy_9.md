## Lecture #9 [Link](https://www.youtube.com/watch?v=qf82-r9hl2Y)
#### recursive sorting
#### quick sort by Tony Hoare
 
* W(n*log(n))
* не всегда работает хорошо, существуют такие массивы, на которых она работает плохо как O(n*n)
* сортирующее действие выполняется на прямом ходу рекурсии не требует дополнительной памяти
* "разделяй и властвуй"

* Логически сортировка разбивает все на 3 группы:
1. группа "солдатов" меньше по росту произвольного "барьерного" элемента
2. группа равных по росту (этих дальше сортировать не надо)
3. группу тех, кто "выше"

#### merge sort
* O(nlog(n))
* сортирующее действие выполняется на обратном ходу рекурсии 
* нужно O(n) дополнительной памяти
 
* разделяем на два списка:
1. часть списка от 0 до n//2 не включительно
2. от n//2 включительно до n не включительно
* далее каждый список сортируется (как-то)
* потом сравниваем поэлементно и формируем конечный список (двигаемся по двум индексам).
* При равенстве элементов уславливаемся из какого списка взять первым и вторым
* в конце оин список будет пустым, а во втором последовательно
* отсортированною будут находиться "большие" элементы, которые достаточно "слиять"
* с результирующим списком

Сортировка называется ***устойчивой***, если она не меняет порядок равных элементов
(сортируемая характеристика может быть не единственной у объекта)
один и тот же алгоритм сортировки может быть реализован как устойчиво, так и неустойчиво

```python
def merge(A:list,B:list):
 C=[0]*(len(A)+len(B))
 i=k=n=0
 while i < len(A) and k < len(B):
  if A[i] <= B[k]: # делаем "устойчивую" реализацию алгоритма
   C[n]=A[i]
   i+=1
   n+=1
  else:
   C[n]=B[k]
   k+=1
   n+=1
 while i<len(A): # возможно ничего не "залил", поскольку i > len(A) уже
  C[n]=A[i]
  i+=1
  n+=1
 while k<len(B):
  C[n]=B[k]
  k+=1
  n+=1
 return C
# рекурсивная функция сортировки

def merge_sort(A):
 if len(A)<=1:
  return
 middle=len(A)//2
 L=[A[i] for i in range(middle)]
 R=[A[i] for i in range(middle,len(A))]
 merge_sort(L)
 merge_sort(R)
 C=merge(L,R)
 for i in range(len(A)):
  A[i]=C[i]
```

#### сортировка ТониХоара (QuickSort)
в самом питоне сортировка - прагматичная, которая является гибридом разных сортировок
случайный элемент выбираем первый (т.е. барьерный = 1 элементу массива)

```python
def hoar_sort(A):
 if len(A)<=1:
  return # None
 L=[]
 M=[]
 R=[]
 barrier=A[0]
 for x in A:
  if x<barrier:
   L.append(x)
  elif x==barrier:
   M.append(x)
  else:
   R.append(x)
 hoar_sort(L)
 hoar_sort(R)
 k=0
 for x in L+M+R:
  A[k]=x
  k+=1
```

#### проверка сортировки массива за O(n)

```python
def check_sorted(A,ascending=True):
 """ проверка отсортированности массива за O(n) """
 flag=True
 s=2*int(ascending)-1
 for i in range(len(A)-1):
  if s*A[i]>s*A[i+1]:
   flag=False
   break
 return flag
```

#### бинарный поиск  массиве
сортировка нужна на самом деле для быстрого поиска!
[1,2,2,2,3,4,5,5,5,5,5,7,7,7,7,7]
left_bound
right_bound

```python
#[1,2,2,2,3,4,5,5,5,5,5,7,7,7,7,7]
middle = (left + right)//2
```
